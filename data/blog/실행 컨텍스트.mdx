---
title: 실행 컨텍스트(Execution Context)
date: '2023-06-28'
tags: ['javascript', '프론트엔드']
draft: false
summary: '실행 컨텍스트에 대해 알아보자'
---

실행 컨텍스트는 ***실행할 코드에 제공할 환경 정보들을 모아놓은 객체***입니다. 동일한 환경에 있는 코드들을 실행할 때
필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는
코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장합니다. 예제를 통해 살펴보겠습니다.

```js
var a = "1";
function outer() {
	function inner() {
		console.log(a);
		var a = "2";
	}
	inner();
	console.log(a);
}
outer();
console.log(a);
```

자바스크립트는 코드가 실행되면 콜 스택에 실행 컨텍스트가 쌓이게 됩니다. 스택은 LIFO(후입선출) 구조를 갖는 자료 구조입니다.
이 말은 가장 마지막에 들어온 실행 컨텍스트가 가장 먼저 처리된다는 것을 의미합니다. 위 코드의 실행 순서를 정리해 보면 다음과 같습니다.

> * 1. 전역 컨텍스트가 콜 스택에 담깁니다.
> * 2. outer 함수가 호출되면서 outer 함수의 실행 컨텍스트가 콜 스택에 담깁니다.
> * 3. inner 함수가 호출되면서 inner 함수의 실행 컨텍스트가 콜 스택에 담깁니다.
> * 4. inner 함수의 실행이 완료되면 inner 함수의 실행 컨텍스트가 콜 스택에서 제거됩니다.
> * 5. outer 함수의 실행이 완료되면 outer 함수의 실행 컨텍스트가 콜 스택에서 제거됩니다.
> * 6. 전역 컨텍스트의 실행이 완료되면 전역 컨텍스트가 콜 스택에서 제거됩니다.

따라서 위 코드는 최종적으로 다음과 같은 결과를 반환합니다.
```console
undefined
1
1
```

위 과정을 그림으로 표현하면 다음과 같습니다.

![](/static/images/context.PNG)

스택 구조를 생각해 보면 한 실행 컨텍스트가 콜 스택의 제일 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점이란 걸
알 수 있습니다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한
환경 정보들을 수집해서 실행 컨텍스트에 저장합니다. 이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 우리가 코드를 통해
직접적으로 확인할 수는 없습니다. 다음은 실행 컨텍스트 내부에 담기는 정보들에 대해 간단하게 살펴보겠습니다.

> * VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보인 environmentRecord, 외부 환경 정보인 outerEnvironmentReference 가
포함되어 있습니다.
> * LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됩니다.
> * ThisBinding : this 식별자가 바라봐야 할 대상 객체입니다.

### environmentRecord와 호이스팅

environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됩니다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한
함수가 있을 경우 그 함수자체, var로 선언된 변수의 식별자 등이 식별자에 해당합니다. 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 ***순서대로*** 수집합니다.
~~~
전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체, 즉 전역 
객체를 활용합니다. 전역 객체에는 브라우저의 window, Node.js의 global 객체 등이 있으며, 이들은 
자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.
~~~
변수 정보를 수집하는 과정을 모두 마쳤더라도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태입니다. 코드가 실행되기 전임에도 불구하고
자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈입니다. 여기서 한번씩 들어보셨을 ***호이스팅***이라는 개념이
등장합니다. 호이스팅은 '끌어올리다'라는 의미로 쉽게 말하자면 '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다' 라고
해석할 수도 있을 것입니다. 호이스팅은 변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념입니다. 다시 말해 자바스크립트 엔진이
실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하자는 의미로 볼 수 있습니다. 간단한 예제로 한번 살펴보겠습니다.
```js
function a(x) {
  console.log(x);
  var x;
  console.log(x);
  var x = 2;
  console.log(x);
}
a(1);
```
위 코드에서 a함수의 실행 컨텍스트가 생성될 때 VariableEnvironment의 environmentRecord에는 매개변수 `x`, 변수 선언 `x`, 변수 선언 `x`가 순서대로 수집됩니다.
따라서 실행 결과는 다음과 같습니다.
```console
1
1
2
```
<br />
### outerEnvironmentReference와 스코프, 스코프 체인

스코프는 식별자에 대한 유효범위입니다. 함수 `A`가 있다고 가정해 보겠습니다. 함수 `A` 바깥에서 선언한 변수는 `A` 함수의 외부뿐 아니라 내부에서도 접근이 가능하지만,
내부에서 선언한 변수는 오직 `A`내부에서만 접근할 수 있습니다.
```js
var a = 1;
function A() {
	var b = 2;
	console.log(a);
	console.log(b);
}
A();
console.log(b);
```
```console
1
2
Uncaught ReferenceError: b is not defined
```
이러한 ***식별자의 유효범위***를 안에서부터 바깥으로 차례로 검색해나가는 것을 ***스코프 체인***이라고 합니다. 이를 가능하게 하는 것이 바로
***LexicalEnvironment***의 두 번째 수집 자료인 ***outerEnvironmentReference***입니다. ***outerEnvironmentReference***는 현재 호출된 함수가 선언될
당시의 ***LexicalEnvironment***를 참조합니다. 여기서 `선언될 당시`라는 말을 주의깊게 봐야합니다. `A`함수가 선언될 당시의 ***outerEnvironmentReference***는
전역 컨텍스트의 ***LexicalEnvironment***를 참조하고 있으며, 해당 환경의 ***environmentRecord***에 `a`와 같은 변수의 정보들이 기록되어 있습니다. <br />
따라서 함수 내부에서 ***outerEnvironmentReference*** 를 통해 상위 컨텍스트의 ***LexicalEnvironment*** 에 접근해 ***environmentRecord*** 에서 변수 `a`를
사용할 수 있게 되는 것입니다. <br />

그리고 각 ***outerEnvironmentReference***는 오직 자신이 선언된 시점의 ***LexicalEnvironment***만 참조하고 있기 때문에 가장 가까운 요소부터 차례대로만
접근할 수 있는 것입니다. 이런 구조적 특성 때문에 여러 스코프에서 동일한 식별자를 선언한 경우에는 ***무조건 스코프 체인 상에서 가장 먼저 발견된 식별자***에만
접근이 가능합니다.
<br />
### ThisBinding
실행 컨텍스트의 `thisBinding`에는 this로 지정된 객체가 저장됩니다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체자 저장됩니다.
그밖에는 함수를 호출하는 방법에 따라 this에 저장되는 대상이 달라집니다. this에 대한 정리는 [***여기***](https://www.oh-blog.site/blog/this)서 볼 수 있습니다.

