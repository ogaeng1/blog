---
title: 좋은 CSS 설계하기
date: '2023-09-28'
tags: ['css']
draft: false
summary: 'CSS 설계 기법과 방법'
---

이 글은 도서 <span style={{ color: "violet" }}>다양한 예제로 배우는 CSS 설계 실전 가이드</span>를 참고하여 저의 생각과 내용을
정리한 글입니다.
<br />

## CSS 이해하기

CSS는 프로그래밍언어에 비해 문법도 간단하고 조금만 학습한다면 누구나 다룰 수 있습니다. 하지만 쉽게 배울 수 있다는 점이
CSS가 어려운 이유이기도 합니다. CSS가 등장하기 전에는 스타일을 각 요소의 전용 속성이나 style 속성으로 일일이 지정했습니다.
```html
<p style="color: blue">파란색 텍스트입니다.</p>
```
하지만 이 방법에는 문제가 있습니다.
> * HTML이나 XML은 본래 문서 구조를 의미하므로 스타일을 지정하는 것은 바람직하지 않다.
> * 같은 스타일 요소를 여러 페이지마다 사용하려면 수정할 때 그만큼 반복 수정을 해야 한다.

이 문제를 해소하기 위해 CSS가 등장했습니다. 우리는 CSS가 HTML이나 XML의 각 요소를 꾸미고, 문서의 구조와 스타일을 분리하는 역할을 하는
것으로 알고 있습니다.
```html
<p>파란색 텍스트입니다.</p>

// css
p {
	color: blue;
}
```
이렇게 문서와 스타일을 분리함으로써 위에서 언급한 문제점들을 해결할 수 있었지만, 막상 또 다른 문제가 발생합니다.
바로 <span style={{ color: "red" }}>페이지 수가 늘어남에 따라 CSS가 복잡해지고 관리하기 어렵다</span>는 점입니다. 물론
한 페이지만으로도 웹 사이트라 칭할 수 있지만, 페이지 수에 최대라는 개념이 없기 때문에 100페이지부터 많게는 10,000페이지가 넘어가는
웹 사이트도 있습니다. 규모가 큰 웹 사이트일수록 스타일 규칙을 확실하게 정한 뒤에 CSS를 작성하는게 좋습니다. 그렇지 않으면 특정 페이지에서
요소의 스타일을 변경했을 때 해당 CSS파일을 사용하는 모든 페이지에도 스타일 변경이 적용되어 버리기 때문입니다.

최근에는 웹사이트에 대한 요구 사항들이 복잡해짐에 따라 CSS를 작성할 때 신경 써야 할 부분이 많아졌습니다. 지금까지 여러 회사나 뛰어난
시니어 개발자까지 어떻게 하면 <span style={{ color: "red" }}>CSS를 쉽게 관리할 수 있도록 유지할까?</span>라는 문제를 해결하기 위해
노력해 왔습니다. 이 문제는 어디까지나 각자의 위치에서 생각하는 부분이기 때문에 회사나 개인의 실력 차로 인해 다음과 같은 문제가 발생했습니다.
> * 규칙을 확실히 정리하지 않으면 혼자 개발을 수행하게 되므로 코드를 기술하는 방법이 어긋난다.
> * 문서화되어 있지 않으면 다른 사람과 협력해서 작업을 수행할 때 코드를 기술하는 방법이 어긋난다.
> * 너무 쉽게 생각하기 때문에 애초에 규칙으로서의 역할을 하지 못한다.

이런 상황을 해결하기 위한 것이 바로 CSS 설계입니다. 다양한 CSS 설계 방법이 있지만, <span style={{ color: "red" }}>어떤 설계 방법이 가잫 좋은지</span>에 대한 답은
명확하게 단정지을 수 없습니다. 그 이유는 웹 개발의 규모가 제각각이고 기업, 전자상거래 등 종류 또한 다양하기 때문에 CSS 설계에 있어서 규모나 개발하는
웹사이트 특성에 따라 최적의 방법이 각각 다르기 때문입니다. 하지만 이 모든 CSS에서 공통점을 찾을 수 있습니다.
> * 추상화한다.
> * 나눈다.

<strong>추상화한다</strong>라는 말의 의미는 <strong>다른 스타일 사이에서 공통화할 수 있는 것은 무엇인가?</strong>, <strong>공통된 부분을 추출해서 하나로 모을 수 있는가?</strong>를
이미지화하는 작업이라고 생각하면 이해하기 쉬울 것입니다. <strong>나눈다</strong>는 것은 크게 세 가지 방법으로 생각할 수 있습니다.
> * 파일을 나눈다.
> * 부품(parts) 크기로 나눈다.
> * 역할에 따라 이름을 나눈다.

<br />
## 리셋 CSS

우리는 보통 프로젝트에서 CSS를 작성하기 시작할 때 가장 먼저 베이스 스타일을 정리합니다. 이 과정에서 일반적으로 리셋 CSS(Reset CSS)를 사용합니다.
그렇다면 리셋 CSS가 왜 필요하게 되었는지부터 살펴보겠습니다.

각 브라우저는 고유의 기본 스타일을 가지고 있어서 스타일링을 전혀 하지 않은 HTML이라 할지라도 최소한의 형태를 보장할 수 있습니다. 하지만 이를
통일하지 않은 채 CSS를 만들면 <strong>어떤 브라우저에서는 의도한 대로 깔끔하게 보이지만</strong>, <strong>다른 브라우저에서는 의도한 대로 표시되지 않는</strong>
상황이 발생합니다. 이러한 문제를 해결하기 위해 기본 스타일을 정의해야 하는데 일반적으로 <span style={{ color: "red" }}>하드 리셋(Hard Reset)</span>이라는 방법과
<span style={{ color: "red" }}>노멀라이즈(Normalize)</span>라는 방법을 사용합니다.

> * ### 하드 리셋 계열 CSS

하드 리셋 계열 CSS는 긴 역사를 가지고 있습니다. 하드 리셋 계열 CSS에도 몇 가지의 종류가 있지만 공통적인 특징으로는 각 요소의 여백을 없애거나,
폰트 사이즈를 통일하는 방법 등이 있습니다. 이러한 특성으로 볼 때 하드 리셋 계열 CSS는 브라우저의 기본 스타일을 활용하지 않는 디자인 프로젝트에 적합하다고
볼 수 있습니다.

> * ### 노멀라이즈 계열 CSS

노멀라이즈 계열 CSS는 하드 리셋 계열 CSS를 대체한다는 목적을 띠고 있습니다. 브라우저 간 차이 혹은 버그를 없애면서 유용한 기본 스타일은 그대로 활용하는
노멀라이즈 계열 CSS는 기본 스타일에 가까운 형태로 스타일을 정의할 수 있는 점이 특징입니다. 따라서 노멀라이즈 계열의 CSS는 브라우저의 기본 스타일을 많이
활용하는 디자인 프로젝트에 적합하다는 것을 알 수 있습니다.

### 리셋 CSS가 미치는 영향

CSS 설계시 어떤 방법을 사용해도 무방하지만 다음과 같은 사항을 염두에 두어야 합니다.
> * 잘못 선택하면 모듈 작성 시 코드와 개발 비용이 증가한다.
> * 중간에서 다른 계열로 변경하는 것은 현실적이지 않다.

<br />

## 좋은 CSS 설계의 네 가지 목표

> * 예측 가능하다.
> * 재사용 가능하다.
> * 유지 보수 가능하다.
> * 확장 가능하다.

### 1. 예측 가능하다
<strong>예측 가능하다</strong>라는 말은 <strong>스타일링이 기대한 대로 동작하는지</strong>, <strong>스타일링 영향 범위를 예측할 수 있는지</strong>를 의미합니다.
새로운 스타일링을 추가하거나 기존 스타일링을 업데이트하더라도 자신이 의도하지 않은 위치에 영향을 주지 않아야 한다는 것입니다.

### 2. 재사용 가능하다
기존 부품을 다른 위치에서도 사용하고 싶은 경우에 코드를 일일이 다시 작성하거나 덮어쓰지 않아도 <strong>재사용 가능한</strong>상태를 말합니다. 이를 위해서는
스타일링이 확실하게 추상화되어 있고 적절하게 분리되어 있어야 합니다.

### 3. 유지 보수 가능하다
새로운 모듈이나 기능을 추가, 변경 혹은 그 배치를 바꿨을 때 기존 CSS를 리팩토링할 필요가 없는 상태가 <strong>유지 보수 가능한</strong>상태입니다.

### 4. 확장 가능하다
<strong>확장 가능하다</strong>라는 말은 CSS를 다루는 인원 수에 상관하지 않고 문제없이 관리할 수 있는 상태를 의미합니다. 초반 단계부터 <strong>확장 가능한</strong>
상태의 CSS인지 아닌지 고려해야 합니다.

<br />

## CSS 설계 실전과 여덟 가지 포인트

> * 1. 특성에 따라 CSS를 분류한다.
> * 2. HTML과 스타일링을 느슨하게 결합한다.
> * 3. 영향 범위를 지나치게 넓히지 않는다.
> * 4. 특정한 콘텍스트에 지나치게 의존하지 않는다.
> * 5. 상세도를 지나치게 높이지 않는다.
> * 6. 클래스 이름에서 영향 범위를 유추할 수 있다.
> * 7. 클래스 이름에서 형태, 기능, 역할을 유추할 수 있다.
> * 8. 확장하기 쉽다.

<br />

# CSS 설계 기법

CSS 설계 기법에는 여러가지가 있지만 여기에선 세 가지 기법만 다룹니다.

## <span style={{ color: "skyblue" }}>OOCSS (Object Oriented CSS)</span>

> * 레고처럼 자유로운 조합이 가능한 모듈의 집합을 만든다.
> * 그 모듈을 조합해 페이지를 만든다.
> * 그리하여 신규 페이지를 만드는 경우에도 기본적으로 추가로 CSS를 만들 필요가 없다.

위와 같은 발상으로 만들어진 OOCSS는 다른 CSS 설계 기법에도 조금씩 영향을 주었는데, 이 레고와 같은 모듈을
구현하기 위한 구체적인 수법으로 다음 두 가지 원칙을 들 수 있습니다.
> * 스트럭처(구조)와 스킨(화면) 분리
> * 컨테이너와 콘텐츠 분리

### 스트럭처와 스킨 분리

우선 버튼 두 종류의 버튼이 있다고 가정해 보겠습니다.
```html
<main id="main">
	<button class="btn-general">기본 버튼</button>
	<button class="btn-wraning">취소 버튼</button>
</main>
```
```css
#main .btn-general {
	display: inline-block;
	width: 300px;
	max-width: 100%;
	padding: 20px 10px;
	background-color: #e25c00;
	box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
	color: #fff;
	font-size: 18px;
	line-height: 1.5;
	text-align: center;
}

#main .btn-wraning {
	display: inline-block;
	width: 300px;
	max-width: 100%;
	padding: 20px 10px;
	background-color: #f1de00;
	box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
	color: #222;
	font-size: 18px;
	line-height: 1.5;
	text-align: center;
}
```
background-color 와 color를 제외한 나머지 코드는 동일합니다. 버튼 구성을 보면 "버튼은 구조(가로 길이나 높이 등)와 형태(박스의 그림자나 배경 색상, 문자 색상 등)를
조합해서 만들어진다"고 생각하는게 "스트럭처와 스킨을 분리"하는 사고방식입니다.

스트럭처에 해당하는 속성은 크게 다음과 같습니다. <br />
> * width
> * height
> * padding
> * margin

스킨에 해당하는 속성은 크게 다음과 같습니다.
> * color
> * font
> * background
> * box-shadow
> * text-shadow

위와 같이 구분할 수 있지만 OOCSS에서는 명확하게 결정되어 있는 것은 아닙니다. 위 내용들을 토대로 "스트럭처와 스킨 분리"에 따라 코드를 수정해보면
다음과 같습니다.
```html
<main id="main">
	<button class="btn general">기본 버튼</button>
	<button class="btn wraning">취소 버튼</button>
</main>
```
```css
/* 스트럭처 */
#main .btn {
	display: inline-block;
	width: 300px;
	max-width: 100%;
	padding: 20px 10px;
	box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
	font-size: 18px;
	line-height: 1.5;
	text-align: center;
}

/* 스킨 */
#main .general {
	background-color: #e25c00;
	color: #fff;
}

#main .wraning {
	background-color: #f1de00;
	color: #222;
}
```
이렇게 하면 다른 색상의 버튼을 추가하더라도 단지 몇 줄의 코드를 작성하는 것으로도 구현할 수 있게 됩니다.

### 컨테이너와 콘텐츠 분리

앞에서 본 예시에서는 버튼 모듈은 id 속성에 main이 지정된 main 요소 안에 포함되어 있습니다. 하지만
이 상태에서는 버튼을 main 밖에서 사용하려 해도 그럴 수 없습니다. 이 문제에 대한 해결 방법은 아주 간단합니다.
버튼 모듈을 main 밖에서도 동작하도록 CSS 셀렉터를 수정하면 됩니다. 컨테이너와 콘텐츠 분리라는 것은 "모듈을 가능한 특정한 영역에
의존하지 않도록 한다"는 지침을 의미합니다.

```html
<main id="main">
	<button class="btn-general">기본 버튼</button>
	<button class="btn-wraning">취소 버튼</button>
</main>
<!-- main에 의존하지 않으므로, 푸터에도 같은 형태의 버튼을 사용할 수 있음 -->
<footer>
	<button class="btn-general">기본 버튼</button>
</footer>
```
```css
/* 스트럭처 */
.btn {
	display: inline-block;
	width: 300px;
	max-width: 100%;
	padding: 20px 10px;
	box-shadow: 0 3px 6px rgba(0, 0, 0, .16);
	font-size: 18px;
	line-height: 1.5;
	text-align: center;
}

/* 스킨 */
.general {
	background-color: #e25c00;
	color: #fff;
}

.wraning {
	background-color: #f1de00;
	color: #222;
}
```

지금까지 OOCSS의 대원칙인 두 가지 사고방식에 대해 설명했습니다. 사실 OOCSS에서 명확하게 규칙이라고 불리는 것은 많지 않습니다.
OOCSS는 CSS 설계의 기초 중의 기초가 되는 내용들이므로 꼭 기억하도록 합시다.

## <span style={{ color: "skyblue" }}>SMACSS</span>

SMACSS는 (Scalable and Modular Architecture for CSS)의 약어로 CSS 코드를 그 역할에 따라 분류한 것이 특징으로 다섯 가지 분류에
따라 각각 규칙을 설정하고 있습니다.
> * 베이스(Base)
> * 레이아웃(Layout)
> * 모듈(Module)
> * 스테이트(State)
> * 테마(Theme)

### 베이스 규칙

베이스 규칙에서는 프로젝트의 표준 스타일을 정의합니다. 베이스 규칙에서 사용하는 셀렉터는 주로 요소형 셀렉터지만
그 외에 다음 셀렉터도 사용합니다.
> * 자녀 셀렉터
> * 손자 셀렉터
> * 의사 클래스
> * 속성 셀렉터
> * 인접 형제 셀렉터
> * 일반 형제 셀렉터

하지만 기본 규칙을 너무 많이 정의해 놓으면 영향 범위가 넓어지게 됩니다. 또한 "프로젝트 내에서 각 요소가 표준으로
어떻게 동작하는가"를 정의하기 위한 규칙이기 때문에, 특정한 상황에서의 사용을 가정하는 ID 셀렉터나 클래스 셀렉터에는 사용할 수 없습니다.

### 레이아웃 규칙

레이아웃 규칙은 헤더나 메인 영역, 사이드 바, 푸터 등 웹사이트의 큰 틀을 구성하는 큰 모듈에 관한 규칙입니다. 레이아웃을 구성하는 것의
대부분은 특정 페이지에서 한 차례만 사용되는 것이 많으므로, ID 셀렉터를 활용한 스타일링을 허용합니다. 레이아웃과 관련해서 반복적으로 사용
하는 모듈의 경우에는 클래스 셀렉터를 이용합니다.

### 모듈 규칙

모듈 규칙에 해당하는 모듈은 레이아웃 모듈 안에 배치되는 것을 가정하고 있습니다.
> * 타이틀(Title)
> * 버튼(Button)
> * 카드(Card)
> * 내비게이션(Navigation)
> * 캐러셀(Carousel)

위와 같이 레이아웃 모듈 안에 배치할 수 있는 개별 모듈이라면 SMACSS에서는 모두 모듈 규칙에 해당합니다. 또한, 모듈을 만들 때는
다음과 같은 두가지 사항에 주의해야 합니다.
> * 가급적 요소형 셀렉터를 사용하지 않는다.
> * 특정한 콘텍스트에 지나치게 의존하지 않는다.

### 스테이트 규칙

스테이트는 기존 스타일을 덮어쓰거나 확장하기 위해 사용합니다. 스테이트 규칙의 상태 스타일은 다음과 같이 구분할 수 있습니다.
> * 상태 스타일은 레이아웃이나 모듈에 할당할 수 있다.
> * 상태 스타일은 자바스크립트에 의존한다는 의미를 갖는다.

스테이트 규칙에 따른 상태 스타일의 클래스 이름은 모두 "-is"라는 접두사를 붙입니다. 또한 기존 스타일을 모두 덮어써서 상태 스타일을
반영하는 것을 기대하기 때문에 필요한 경우에는 !important 사용도 권장합니다.

### 테마 규칙

테마 규칙은 사이트 내 레이아웃이나 색상, 텍스트 처리 등을 일정한 규칙에 따라 덮어쓰는 것으로, 기존의 다양한 스타일링이 덮어쓰기의 대상이 됩니다.
테마 규칙의 대상이 되는 모듈 수가 그리 많지 않다면 별도의 노력 없이도 테마 규칙 대상이 되는 모듈과 그렇지 않은 규칙을 구분할 수 있을 것입니다.


## <span style={{ color: "skyblue" }}>BEM</span>

BEM은 블록(Block), 엘리먼트(Element), 모디파이어(Modifier)의 약어로 사용자 인터페이스를 독립된 블록으로 분리함으로써 복잡한 페이지에서도
간단하고 신속하게 개발을 수행하는 것이 목적입니다.

### BEM 기본

BEM 전체에 공통으로 적용되는 기본 규칙에 관해 설명합니다.
> * BEM에서는 CSS스타일링에 있어서 요소형 셀렉터나 ID 셀렉터 사용을 권장하지 않습니다.
> * 클래스 이름은 영소문자를 사용하고, 단어는 하이픈으로 연결한다.

### Block 기본

BEM에서는 Block을 "논리적이고 기능적으로 독립한 페이지 모듈"이라고 정의하고 있습니다. <br />
Block의 이름 규칙은 다음과 같습니다.
> * 한 단어인 경우 <br />
menu, block 등
> * 두 단어 이상인 경우 <br />
block-name, global-nav 등

클래스 이름은 "그것이 무엇인지" 알 수 있는 의미를 담아서 만듭니다.

### Element 기본

Element는 "Block을 구성하고, Block 외부에서는 독립해서 사용할 수 없는 것"으로 정의되어 있습니다.
Element 클래스 이름은 Block의 이름을 상속받고 언더스코어 두 개를 입력한 뒤 Element 이름을 붙입니다.
> * 한 단어인 경우 <br />
menu__item
> * 두 단어 이상인 경우 <br />
global-nav__link-menu__item

Element 이름에 사용하는 단어 또한 Block과 마찬가지로 "무엇인지"를 의미하는 단어를 사용합니다.

### Modifier 기본

Modifier는 "Block 혹은 Element의 모습이나 상태 또는 움직임을 정의하는 것"이라 정의되어 있습니다. 그리고 Block 혹은 Element에 대한
선택 요소이므로 반드시 있어야 하는 것은 아닙니다. Modifier는 단독으로 사용할 수 없으며 반드시 Block이나 Element 클래스 이름이 있는 상태에서,
두 번째 이후 클래스 이름으로 붙여 사용해야 합니다.
```html
<!-- 예 -->

<a class="button button_size_s" href="#">버튼</a>
```