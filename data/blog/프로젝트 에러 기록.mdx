---
title: 제작 과정과 에러 기록
date: '2023-05-13'
tags: ['프론트엔드']
draft: false
summary: '제작 과정과 에러 기록'
---

## 1. Next.js 웹 스토리지 에러

![](/static/images/err1.PNG)

Next.js에서 서버 사이드 렌더링 시 발생하는 에러입니다. Next.js는 서버 사이드 렌더링을
지원하기 때문에 컴포넌트가 서버에서 렌더링될 수 있습니다. 반면 웹 스토리지 객체는 브라우저에서만
사용할 수 있기 때문에 서버에서 렌더링 될때 레퍼런스 에러를 발생 시켰습니다. 이러한 문제를 해결하기
위해 해당 코드가 클라이언트에서만 실행될 수 있도록 useEffect 훅을 사용하여 변경 하였습니다.

```tsx
const [user, setUser] = useState<string | null>("");

useEffect(() => {
    if (typeof window !== 'undefined' && window.sessionStorage) {
        setUser(sessionStorage.getItem("user"));
    }
}, []);

if (user) {
    return (
        ....
    )
}

```

## 2. Debounce 적용 시키기

```ts
import { ToastContainer, toast } from 'react-toastify';
....

const onAddWishList = async () => {
    if (product) {
        if (loginUser) {
            const user = sessionStorage.getItem("user")
            if (user) {
                const wishlistRef = doc(collection(db, "wishlists"), user)
                const docSnap = await getDoc(wishlistRef)
                if (docSnap.exists()) {
                    const products = docSnap.data().products
                    if (!products.some((p: ProductState) => p.id === product.id)) {
                        await setDoc(wishlistRef, {
                            products: [...products, product]
                        }, { merge: true })
                        toast.success("관심상품에 추가되었습니다.")
                    } else {
                        toast.error("같은 상품을 추가할 수 없습니다.")
                    }
                } else {
                    await setDoc(wishlistRef, {
                        products: [product]
                    })
                    toast.success("관심상품에 추가되었습니다.")
                }
            }
        } else {
            setModal(true);
        }
    }
}

{/* 중략 */}

return (
  ...
  <button className="w-[120px] h-[50px] px-[10px] rounded-[10px] border text-[16px] hover:shadow-custom" onClick={debounceWishList}>❤ 관심상품</button>
  <ToastContainer
      position="top-center"
      autoClose={1500}
      limit={1}
      theme="light"
  />
  ...
)
```

프로젝트 코드의 일부입니다. 나의 장바구니에 상품을 추가하는 함수입니다. 버튼을 누르면 함수가 실행되면서 조건에 따른 toastify가 실행됩니다.
하지만, 여기서 사용자가 의도적으로 버튼을 여러번 눌렀을 때 누른 횟수 만큼 함수가 실행된다면 성능에 문제가 될 것이라고 판단했습니다.
물론 지금은 규모가 작은 개인 프로젝트이기 때문에 성능적인 면에서 엄청난 효과를 볼 수 있다고 할 순 없겠지만 이런 기술을 활용하면 나중에
유용하게 사용할 수 있을것 같아 적용해 보기로 했습니다.

우선 디바운스를 적용하기 전 입니다.

![](/static/images/no-debounce.gif);

관심상품 버튼을 누르면 조건에 따라 toastify가 실행됩니다. 위에선 해당 상품이 이미 관심상품에 담겨있기 때문에 관심상품에 추가할 수 없다는
메세지가 출력되고 있습니다. toastify가 실행되고 1.5초 뒤에 자동으로 닫히게 설정되어 있습니다. 그리고 여러번을 클릭해도 화면에 최대 1개만
보여주도록 되어있습니다. 하지만 위 사진처럼 연속으로 3번 빠르게 버튼을 누르면 차례로 실행되는걸 볼 수 있습니다. 만약 사용자가 저 버튼을
100번 눌렀다고 가정해 보겠습니다. 그러면 다음과 같이 실행될 것입니다. <br />
"첫 toastify가 실행 후 종료 -> 두 번째 toastify 실행 후 종료 -> .... -> 마지막 toastify 실행 후 종료" <br />
이 과정을 간단하게 그림으로 표현해 보겠습니다.

![](/static/images/logic.PNG)

저는 화면에 toastify가 나타나는 개수를 1개로 제한했기 때문에 굉장히 오랜시간이 걸릴 것입니다. 바로 이런 문제를 해결할 수 있는 방법이 바로
"Debounce" 라는 기법입니다. 디바운스는 짧은 시간 내에 발생하는 이벤트를 무시하고, 일정 시간이 지난 후에 마지막 이벤트만 처리하는 기법입니다.
다음은 기존의 코드에 디바운스를 적용한 코드입니다.
```ts
const debounce = <T extends (...args: any[]) => any>(func: T, wait: number) => {
    let timeout: ReturnType<typeof setTimeout> | undefined;
    return (...args: Parameters<T>): void => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), wait);
    };
};
    
const onAddWishList = async () => {
    if (product) {
        if (loginUser) {
            const user = sessionStorage.getItem("user")
            if (user) {
                const wishlistRef = doc(collection(db, "wishlists"), user)
                const docSnap = await getDoc(wishlistRef)
                if (docSnap.exists()) {
                    const products = docSnap.data().products
                    if (!products.some((p: ProductState) => p.id === product.id)) {
                        await setDoc(wishlistRef, {
                            products: [...products, product]
                        }, { merge: true })
                        toast.success("관심상품에 추가되었습니다.")
                    } else {
                        toast.error("같은 상품을 추가할 수 없습니다.")
                    }
                } else {
                    await setDoc(wishlistRef, {
                        products: [product]
                    })
                    toast.success("관심상품에 추가되었습니다.")
                }
            }
        } else {
            setModal(true);
        }
    }
}

const debounceWishList = debounce(onAddWishList, 300);

...

return (
  ...
    <button className="w-[120px] h-[50px] px-[10px] rounded-[10px] border text-[16px] hover:shadow-custom" onClick={debounceWishList}>❤ 관심상품</button>
    <ToastContainer
        position="top-center"
        autoClose={1500}
        limit={1}
        theme="light"
    />
  ...
)
```
디바운스를 적용시켰으니 결과를 확인해 보겠습니다.

![](/static/images/debounce.gif)

디바운스를 적용시키기 전과 똑같이 관심상품 버튼을 빠르게 3번 눌렀으나, 마지막에 눌린 클릭 이벤트만 실행되는 걸 확인할 수 있습니다.
디바운스가 적용된 과정을 살펴보겠습니다.

![](/static/images/logic2.PNG)

간단하게 표현하자면 마지막에 발생한 이벤트만 실행되는 걸 알 수 있습니다. 이런 방법으로 성능을 개선할 수 있습니다.
디바운스와 비슷하게 "쓰로틀링" 이라는 기법도 있습니다. 이건 추후 따로 공부해서 정리해 보겠습니다.