---
title: 제작 과정과 에러 기록
date: '2023-05-13'
tags: ['프론트엔드']
draft: false
summary: '제작 과정과 에러 기록'
---

## 1. Next.js 웹 스토리지 에러

![](/static/images/err1.PNG)

Next.js에서 서버 사이드 렌더링 시 발생하는 에러입니다. Next.js는 서버 사이드 렌더링을
지원하기 때문에 컴포넌트가 서버에서 렌더링될 수 있습니다. 반면 웹 스토리지 객체는 브라우저에서만
사용할 수 있기 때문에 서버에서 렌더링 될때 레퍼런스 에러를 발생 시켰습니다. 이러한 문제를 해결하기
위해 해당 코드가 클라이언트에서만 실행될 수 있도록 useEffect 훅을 사용하여 변경 하였습니다.

```tsx
const [user, setUser] = useState<string | null>("");

useEffect(() => {
    if (typeof window !== 'undefined' && window.sessionStorage) {
        setUser(sessionStorage.getItem("user"));
    }
}, []);

if (user) {
    return (
        ....
    )
}

```

## 2. Debounce 적용 시키기

```ts
import { ToastContainer, toast } from 'react-toastify';
....

const onAddWishList = async () => {
    if (product) {
        if (loginUser) {
            const user = sessionStorage.getItem("user")
            if (user) {
                const wishlistRef = doc(collection(db, "wishlists"), user)
                const docSnap = await getDoc(wishlistRef)
                if (docSnap.exists()) {
                    const products = docSnap.data().products
                    if (!products.some((p: ProductState) => p.id === product.id)) {
                        await setDoc(wishlistRef, {
                            products: [...products, product]
                        }, { merge: true })
                        toast.success("관심상품에 추가되었습니다.")
                    } else {
                        toast.error("같은 상품을 추가할 수 없습니다.")
                    }
                } else {
                    await setDoc(wishlistRef, {
                        products: [product]
                    })
                    toast.success("관심상품에 추가되었습니다.")
                }
            }
        } else {
            setModal(true);
        }
    }
}

{/* 중략 */}

return (
  ...
  <button className="w-[120px] h-[50px] px-[10px] rounded-[10px] border text-[16px] hover:shadow-custom" onClick={debounceWishList}>❤ 관심상품</button>
  <ToastContainer
      position="top-center"
      autoClose={1500}
      theme="light"
  />
  ...
)
```

프로젝트 코드의 일부입니다. 나의 장바구니에 상품을 추가하는 함수입니다. 버튼을 누르면 함수가 실행되면서 조건에 따른 toastify가 실행됩니다.
하지만, 여기서 사용자가 의도적으로 버튼을 여러번 눌렀을 때 누른 횟수 만큼 함수가 실행된다면 성능에 문제가 될 것이라고 판단했습니다.
물론 지금은 규모가 작은 개인 프로젝트이기 때문에 성능적인 면에서 엄청난 효과를 볼 수 있다고 할 순 없겠지만 이런 기술을 활용하면 나중에
유용하게 사용할 수 있을것 같아 적용해 보기로 했습니다.

우선 디바운스를 적용하기 전 입니다.

![](/static/images/no-debounce.gif)

관심상품 버튼을 누르면 조건에 따라 toastify가 실행됩니다. 위에선 해당 상품이 이미 관심상품에 담겨있기 때문에 관심상품에 추가할 수 없다는
메세지가 출력되고 있습니다. 위 사진은 연속으로 5번 빠르게 버튼을 눌렀을 때 실행되는 화면입니다. 만약 사용자가 저 버튼을
100번 눌렀다고 가정해 보겠습니다. 그러면 다음과 같이 실행될 것입니다. <br />
"첫 toastify가 실행 후 종료 -> 두 번째 toastify 실행 후 종료 -> .... -> 마지막 toastify 실행 후 종료" <br />
이 과정을 간단하게 그림으로 표현해 보겠습니다.

![](/static/images/logic.PNG)

사용자가 여러번 클릭하더라도 단 한번만 실행시킬 수 있다면 성능적인 측면에서 굉장한 효과가 있을 것입니다. 바로 이런 문제를 해결할 수 있는 방법이 바로
"Debounce" 라는 기법입니다. 디바운스는 짧은 시간 내에 발생하는 이벤트를 무시하고, 일정 시간이 지난 후에 마지막 이벤트만 처리하는 기법입니다.
다음은 기존의 코드에 디바운스를 적용한 코드입니다.
```ts
const debounce = <T extends (...args: any[]) => any>(func: T, wait: number) => {
    let timeout: ReturnType<typeof setTimeout> | undefined;
    return (...args: Parameters<T>): void => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), wait);
    };
};
    
const onAddWishList = async () => {
    if (product) {
        if (loginUser) {
            const user = sessionStorage.getItem("user")
            if (user) {
                const wishlistRef = doc(collection(db, "wishlists"), user)
                const docSnap = await getDoc(wishlistRef)
                if (docSnap.exists()) {
                    const products = docSnap.data().products
                    if (!products.some((p: ProductState) => p.id === product.id)) {
                        await setDoc(wishlistRef, {
                            products: [...products, product]
                        }, { merge: true })
                        toast.success("관심상품에 추가되었습니다.")
                    } else {
                        toast.error("같은 상품을 추가할 수 없습니다.")
                    }
                } else {
                    await setDoc(wishlistRef, {
                        products: [product]
                    })
                    toast.success("관심상품에 추가되었습니다.")
                }
            }
        } else {
            setModal(true);
        }
    }
}

const debounceWishList = debounce(onAddWishList, 300);

...

return (
  ...
    <button className="w-[120px] h-[50px] px-[10px] rounded-[10px] border text-[16px] hover:shadow-custom" onClick={debounceWishList}>❤ 관심상품</button>
    <ToastContainer
        position="top-center"
        autoClose={1500}
        theme="light"
    />
  ...
)
```
디바운스를 적용시켰으니 결과를 확인해 보겠습니다.

![](/static/images/debounce.gif)

디바운스를 적용시키기 전과 똑같이 관심상품 버튼을 빠르게 5번 눌렀으나, 마지막에 눌린 클릭 이벤트만 실행되는 걸 확인할 수 있습니다.
디바운스가 적용된 과정을 살펴보겠습니다.

![](/static/images/logic2.PNG)

간단하게 표현하자면 마지막에 발생한 이벤트만 실행되는 걸 알 수 있습니다. 이런 방법으로 성능을 개선할 수 있습니다.
디바운스와 비슷하게 "쓰로틀링" 이라는 기법도 있습니다. 이건 추후 따로 공부해서 정리해 보겠습니다.

## 3. useMemo 활용

```jsx
{/* 중략 */}
const [category, setCategory] = useRecoilState(CategoryState);

useEffect(() => {
    const getData = async () => {
        setLoading(true);
        let q = query(collection(db, "products"));
        if (category === "최신순") {
            q = query(collection(db, "products"), orderBy("createdAt", "desc"));
        } else if (category === "인기순") {
            q = query(collection(db, "products"), orderBy("viewCount", "desc"));
        }

        const querySnapshot = await getDocs(q);

        const products:ProductState[] = [];
        for (const doc of querySnapshot.docs) {
            const data = doc.data();
            const imageUrl = await getDownloadURL(ref(storage, data.imageUrl));
            products.push({ ...data, id: doc.id, imageUrl } as ProductState);
        }
        setProduct(products);
        setLoading(false);
    };
    getData();
}, [category]);
{/* 중략 */}
```

기존 상품리스트를 불러오는 코드입니다. 최신순, 인기순 카테고리에 맞는 데이터를 새로 정렬하기 위해 useEffect훅의 의존성 배열에
category state 값을 넣어주었습니다. 하지만 매번 카테고리가 변경될 때마다 데이터를 호출 하는 상황이 발생했습니다.
![](/static/images/before-memo.gif)


카테고리가 변경될 때마다 매번 데이터가 호출되는 모습입니다. useMemo훅을 활용해 매번 데이터가 다시 호출되는 걸 방지했습니다.
```jsx
{/* 중략 */}
const [product, setProduct] = useRecoilState(productList);
const [category, setCategory] = useRecoilState(CategoryState);

useEffect(() => {
    if (product.length === 0) {
        const getData = async () => {
            setLoading(true);
            let q = query(collection(db, 'products'));
      
            const querySnapshot = await getDocs(q);
      
            const products: ProductState[] = [];
            for (const doc of querySnapshot.docs) {
                const data = doc.data();
                const imageUrl = await getDownloadURL(
                    ref(storage, data.imageUrl)
                );
                products.push({ ...data, id: doc.id, imageUrl } as ProductState);
            }
            setProduct(products);
            setLoading(false);
        };
        getData();
    }
}, []);

const filteredProducts = useMemo(() => {
    if (category === '최신순') {
        return [...product].sort((a, b) => b.createdAt - a.createdAt);
    } else if (category === '인기순') {
        return [...product].sort((a, b) => b.viewCount - a.viewCount);
    } else {
        return product;
    }
}, [category, product]);
{/* 중략 */}
```
![](/static/images/after-memo.gif)

useMemo훅의 의존성 배열에 category와 product를 넣어 카테고리나 상품 정보가 변경될 때만 다시 실행되게 설정했습니다. 위 결과처럼 카테고리가 변경되어도
데이터를 매번 호출하지 않고 카테고리에 맞게 데이터가 변경되는 걸 확인할 수 있었습니다.


## 4. debounce 적용 시 input에 텍스트가 입력되지 않던 문제

검색 기능을 만들던 중 input에 텍스트가 입력될 때마다 이벤트가 발생하게 됩니다. 예를 들어 `피카츄`라는 단어를 입력한다고 가정해 보면
`ㅍ`, `피`, `핔`, `피카`, `피캋`, `피카츄` 이처럼 하나하나 입력 시 모든 이벤트가 발생하게 되어 성능면에서 안좋을 거라 판단하여
사용자가 입력하고자 하는 단어를 모두 입력하고 난 뒤 검색 요청을 보내면 좋을 것 같다는 생각이 들어 디바운스를 적용해 보기로 했습니다.
```tsx
import { useRecoilState } from "recoil";
import { SearchItem } from "@/store/state";
import { BsSearch } from "react-icons/bs";

const Search = () => {
    const [searchQuery, setSearchQuery] = useRecoilState(SearchItem);

    const debounce = <T extends (...args: any[]) => any>(func: T, delay: number) => {
        let timeout: ReturnType<typeof setTimeout> | undefined;
        return (...args: Parameters<T>): any => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), delay);
        };
    };

    const searchHandler = (e: React.ChangeEvent<HTMLInputElement>) => {
        setSearchQuery(e.target.value);
        console.log("디바운스 실행");
    }

    const onDebounce = debounce(searchHandler, 500)
    return (
        <div className="w-full flex items-center mt-[100px]">
            <input 
                type="text" 
                placeholder="검색어를 입력해주세요." 
                className=" border-b-2 outline-none w-3/4 focus:placeholder-transparent focus:border-slate-700 text-[24px]"
                value={searchQuery}
                onChange={onDebounce}
                maxLength={20}
            />
            <button className="flex items-center text-[22px]">
                <BsSearch className="absolute right-0 mr-[27%]" />
            </button>
        </div>
    )
}

export default Search;
```

![](/static/images/err_debounce.gif)

input에 텍스트가 입력되지는 않고 마지막 입력 후 500ms 후 추가적인 입력이 없다면 console만 찍히는 모습입니다. 사용자가 입력한 검색어는
실제로는 `searchQuery`변수에 반영되지만 디바운스에 설정된 시간 동안 사용자의 화면에는 해당 텍스트가 표시되지 않은 것처럼 보였던 것이라고 생각했습니다.
그 이유는 디바운스가 적용된 `onDebounce`함수를 통해 `searchHandler`함수를 호출하는데 디바운스 함수는 제가 설정한 500ms 시간이 지난 후 `searchHandler`
함수를 호출하게 됩니다. 따라서 디바운스 적용 시간이 지나기 전까지는 `searchQuery`변수의 상태가 최신 입력값을 반영하지 않고, 디바운스 함수에 의해
지연되어 input에는 아무런 텍스트가 입력되지 않은 것이라고 판단했습니다. 따라서 코드를 다음과 같이 수정했습니다.

```tsx
import { useRecoilState } from "recoil";
import { SearchItem } from "@/store/state";
import { BsSearch } from "react-icons/bs";
import { useState, useEffect } from "react";

const Search = () => {
    const [searchQuery, setSearchQuery] = useRecoilState(SearchItem);
    const [query, setQuery] = useState(searchQuery);

    const searchHandler = (e: React.ChangeEvent<HTMLInputElement>) => {
        setQuery(e.target.value);
    }

    useEffect(() => {
        const debounce = setTimeout(() => {
            setSearchQuery(query);
        }, 500);
    
        return () => clearTimeout(debounce);
    }, [query, setSearchQuery]);

    return (
        <div className="w-full flex items-center mt-[100px]">
            <input 
                type="text" 
                placeholder="검색어를 입력해주세요." 
                className=" border-b-2 outline-none w-3/4 focus:placeholder-transparent focus:border-slate-700 text-[24px]"
                value={query}
                onChange={searchHandler}
                maxLength={20}
            />
            <button className="flex items-center text-[22px]">
                <BsSearch className="absolute right-0 mr-[27%]" />
            </button>
        </div>
    )
}

export default Search;
```

기존에 디바운스가 적용된 `searchHandler`함수 내에서 `setSearchQuery`를 호출하는 대신 `searchQuery`를 `query` 변수에 저장한 뒤
디바운스 함수에서 `query`변수 값을 사용해 `setSearchQuery`를 호출하는 방법으로 변경했습니다. 이렇게 하면 input에 텍스트를
입력할 때마다 `searchQuery`의 상태가 변경되지만, 실제로는 디바운스 함수가 delay 시간 내에 마지막으로 입력된 값을 기준으로 업데이트를
할 것이라고 생각했습니다. 이렇게 하면 `searchHandler`함수에서 input에 입력된 텍스트를 `query`상태 값에 저장하고 디바운스가 적용된
`useEffect`훅 내부에서 `query`를 사용해 `setSearchQuery`를 호출하도록 하였습니다. 최종 결과는 다음과 같습니다.

![](/static/images/done_debounce.gif)

참고한 블로그 : https://velog.io/@skawnkk/debounce-throttle



## 5. 결제 기능만들기

결론부터 말하자면 실제 결제기능은 구현하지 못했다. 결제 기능을 만들기 위해 찾아 봤던 결제 시스템들은 다음과 같다.

### 1. Stripe

우선 가장먼저 파이어베이스 결제를 찾아봤을 때 가장 많이 보였던 `Stripe`입니다. 하지만 Stripe는 46개의 국가를 지원하는데 그 중
우리나라는 없었다.. Stripe는 사용하지 못하겠다고 판단!

Stripe 지원 국가 : https://stripe.com/

![](/static/images/stripe.PNG)


### 2. 네이버페이

국내에서 사실 가장 흔하게 사용되는 결제 시스템이지 않을까 생각이 든다. 요즘 웬만한 쇼핑에선 네이버페이가 지원 되지 않은 곳을
찾기 힘들 정도.. 하.지.만 !

![](/static/images/naverpay.PNG)

네이버페이 서비스를 이용하려면 사업자등록이 되어있어야 한다.. 나처럼 1인 개발에서는 실제 결제기능을 이용할 수 없다는 사실..

네이버페이 개발자 센터 : https://admin.pay.naver.com/about

++ 카카오페이도 역시 가맹점 신청이 필요하다..


### 3. 페이팔

결론부터 말하자면 최종적으로 페이팔을 활용했다. 하지만 페이팔도 역시 실제 거래를 위해선 해외 계좌가 필요했다..
하지만 페이팔에서 샌드박스 모드와 라이브 모드가 있는데 샌드박스 모드는 테스트 환경을 의미하고 라이브는 실제 온라인 거래를 할 수 있는
모드다. 하지만 라이브 모드를 사용하려면 몇 가지의 인증과 해외 계좌를 등록해야 한다.. 어쩔 수 없이 테스트 모드라도 사용해서
결제 기능을 흉내 내보기로 했다. 페이팔 결제를 쉽게 도와주는 라이브러리도 있다. <br />
페이팔 라이브러리 : https://www.npmjs.com/package/react-paypal-button-v2 <br />
페이팔 개발자 대시보드 : https://developer.paypal.com/dashboard/

사용방법은 굉장히 간단했다. 

![](/static/images/paypal.PNG)

`Create App` 버튼으로 앱을 하나 만들고 Client ID를 적용 시켜주면 된다.


