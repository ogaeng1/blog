---
title: 자바스크립트의 this
date: '2023-06-06'
tags: ['JavaScript']
draft: false
summary: 'this에 대해 알아보자'
---

다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미합니다. 클래스에서만 사용할 수 있기 때문에
혼란의 여지가 많지 않습니다. 하지만 자바스크립트에서의 this는 어디서든 사용할 수 있기 때문에 혼란을 줄 수 있습니다.
우선 this의 정의에 대해 알아보겠습니다.

![](/static/images/this.PNG)

출처 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/

MDN 문서에서는 this를 다음과 같이 정의하고 있는데, 자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됩니다.
실행 컨텍스트는 함수를 호출할 때 생성되기 때문에 다른 말로는 'this는 함수를 호출할 때 결정됩니다.' 라고 볼 수 있습니다. 즉, 함수를
어떤 방식으로 호출하느냐에 따라 값이 달라진다는 말을 뜻합니다. 이렇게 함수가 호출될 때마다 this가 동적으로 결정되는 것을 **바인딩**한다고
표현합니다. 각 실행 문맥에서 this를 바인딩 하는 데에는 규칙들이 존재하는데 이 규칙들 사이에서도 우선순위가 존재합니다. 다음은 바인딩 규칙들에
대해 알아보겠습니다.

## 기본 바인딩

자바스크립트에서 함수를 호출하는 가장 기본적인 방법은 단독으로 호출하는 방법입니다.

```js
function a() {
  console.log(this)
}

a()

// window
```

함수를 실행하게 되면 기본적으로 전역객체에 바인딩됩니다. 실행환경에 따라 전역객체가 달라지는데 브라우저 환경에서는 window,
Node.js 환경에서는 global 객체에 바인딩됩니다. 하지만 여기서 주의해야하는 부분은 '엄격 모드(strict mode)'입니다.

```js
'use strict'

function a() {
  console.log(this)
}

a()
// undefined
```

'use strict' 키워드를 통해 엄격 모드를 사용할 경우 전역객체가 기본 바인딩 대상에서 제외되기 때문에 이런 경우 this가 바인딩 될 객체가
존재하지 않기 때문에 undefined를 출력하게 됩니다.

## 암시적 바인딩

자바스크립트에서는 함수가 객체의 메서드로도 호출이 될 수 있습니다.

```js
const obj_this = {
  food: 'kimchi',
  foodName() {
    return this.food
  },
}

console.log(obj_this.foodName())
// kimchi
```

이런 경우는 this가 바로 앞의 food라는 프로퍼티를 가리키게 됩니다. 이렇게 바인딩 되는 방식을 암시적 바인딩이라 부릅니다. 암시적 바인딩을
사용할 때에도 문제가 발생할 수 있습니다. 바로 함수를 콜백함수로 넘겨서 실행하는 경우입니다.

```js
const obj_this = {
  food: 'kimchi',
  foodName() {
    return this.food
  },
}

fucntion result(callback) {
    console.log(callback());
}

result(obj_this.foodName);

// undefined
```

이런 결과가 나오는 이유는 foodName 메서드 내부의 this 키워드가 result 함수의 콜백으로 전달될 때 obj_this 객체에 대한 참조를 잃어버리기 때문입니다.
그 대신, this는 전역객체를 참조하게 되는데 전역 객체에는 food 속성이 없으므로 undefined가 반환됩니다.
